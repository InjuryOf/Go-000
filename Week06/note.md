## 课程大纲

>- 隔离
>- 超时控制
>- 过载保护
>- 限流
>- 降级
>- 重试
>- 负载均衡
>- 最佳实践



## 课前疑问

> - 

## 课程内容

> - 隔离
>   - 服务隔离：
>     - 动静分离:
>     - 读写分离：主从、Replicaset、CQRS
>   - 轻重隔离（重要性）：核心、快慢、热点
>   - 物理隔离：线程、进程、集群、机房
> - 超时控制
>   - 出现原因：
>     - 网络传递具有不确定性
>     - 客户端和服务端不同的超时控制策略导致的资源浪费
>     - ”默认值“ 策略？
>     - 高延迟服务导致client浪费资源等待
>   - 场景：
>     - 连接超时
>     - 写超时
>     - 读超时
>   - 超时控制策略：
> - 过载保护：
>   - 常用策略：
>     - 令牌桶算法
>     - 漏桶算法
>   - 指标设置问题：
>     - 集群增加机器或减少机器限流阈值的重新设置问题？
>     - 设置限流阈值的依据？
>     - 人力运维成本过高？
>   - 解决方案：
>     - 利特尔法则
>       - CPU、内存作为信号量进行节流
>       - 队列管理: 队列长度、LIFO
>       - 可控延迟算法: CoDel
>   - 如何计算接近峰值的系统吞吐：
>     - CPU：使用一个独立线程进行采样，每隔250ms触发一次。在计算均值的时候，使用简单滑动平均去除峰值影响？
>     - Inflight：当前服务中正在请求的数量
>     - Pass&RT：最近5s、pass为每100ms采样窗口内成功请求的数量，rt为单个采样窗口中平均响应时间
> - 限流
>   - 定义：是指为了保护服务能够正常处理业务请求，对大流量，大并发情况下的请求控制
>   - 常规策略：
>     - 令牌桶、漏桶算法，针对单个节点，无法分布式限流
>     - QPS限流：
>       - 不同请求可能需要不同的资源来处理
>     - 针对用户进行限流控制：
>       - 全局过载时，针对某些”异常“进行控制？
>       - 一定程度上的 ”超卖“ 配额
>     - 按照优先级丢弃
>     - 拒绝请求（也需要成本）
>   - 分布式限流：
>     - 最大最小公平分享
>   - 限流的重要性：
>   - 熔断：断路器
> - 降级：
>   - 降级的本质是提供有损服务
>     - UI 模块化，非核心模块降级。
>     - BFF 层聚合 API，模块降级。
>     - 页面上一次缓存副本。
>     - 默认值、热门推荐等。
>     - 流量拦截 + 定期数据缓存(过期副本策略)。
>   - 降级的处理步骤：
>     - 确定具体采用哪个指标作为流量评估和优雅降级的决定性指标(如，CPU、延迟、队列长度、线程数量、错误等)。
>     - 当服务进入降级模式时，需要执行什么动作？
>     - 流量抛弃或者优雅降级应该在服务的哪一层实现？是否需要在整个服务的每一层都实现，还是可以选择某个高层面的关键节点来实现？
>   - 降级设置的考虑点
>     - 优雅降级不应该被经常触发 - 通常触发条件现实了容量规划的失误，或者是意外的负载。
>     - 演练，代码平时不会触发和使用，需要定期针对一小部分的流量进行演练，保证模式的正常。
>     - 应该足够简单。
>   - 处理策略：
>     - 页面降级、延迟服务、写/读降级、缓存降级
>     - 抛异常、返回约定协议、Mock 数据、Fallback 处理
> - 重试：
>   - 出现场景：当请求返回错误(例: 配额不足、超时、内部错误等)，对于 backend 部分节点过载的情况下，倾向于立刻重试，但是需要留意重试带来的流量放大
>   - 重试策略：
>     - 限制重试次数和基于重试分布的策略(重试比率: 10%)。
>     - 随机化、指数型递增的重试周期: exponential ackoff + jitter
>     - client 测记录重试次数直方图，传递到 server，进行分布判定，交由 server 判定拒绝
>     - 只应该在失败的这层进行重试，当重试仍然失败，全局约定错误码“过载，无须重试”，避免级联重试
> - 负载均衡：
>   - 主要目的是将请求均匀分布给所有每个服务或任务处理
>   - 目标：
>     - 均衡的流量分发
>     - 可靠的识别异常节点
>     - scale-out，增加同质节点扩容。
>     - 减少错误，提供可用性
>   - 负载均衡算法：
>   - 服务分析
> - 最佳实践
>   - 变更管理:
>     70％的问题是由变更引起的，恢复可用代码并不总是坏事。
>   - 避免过载:
>     过载保护、流量调度等。
>   - 依赖管理:
>     任何依赖都可能故障，做 chaos monkey testing，注入故障测试。
>   - 优雅降级:
>     有损服务，避免核心链路依赖故障。
>   - 重试退避:
>     退让算法，冻结时间，API retry detail 控制策略。
>   - 超时控制:
>     进程内 + 服务间 超时控制。
>   - 极限压测 + 故障演练。
>   - 扩容 + 重启 + 消除有害流量。



## 概念 & 知识点

> - CDN-边缘计算
> - kafka
> - 小表广播
> - 缓存：
>   - 主动预热：旁路预热
>   - 通读预热
> - 安全容器（Kata Container）
> - 利特尔法则
> - 拥塞控制
> - Vegas
> - 滑动窗口
> - DRF
> - backOff & Jitter
> - seata

## 引用 & 扩展资料

> - GO语言性能优化：https://cch123.github.io/perf_opt/
> - 限流：https://pkg.go.dev/golang.org/x/time/rate
> - https://allen-kevin.github.io/2017/05/18/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8BVegas/
> - https://www.zhihu.com/question/32255109
> - RollingCounter：https://github.com/go-kratos/kratos/tree/master/pkg/stat/metric
> - https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/
> - 日志：
>   - https://dave.cheney.net/2015/11/05/lets-talk-about-logging
>   - https://www.ardanlabs.com/blog/2013/11/using-log-package-in-go.html
>   - https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html
>   - https://dave.cheney.net/2017/01/23/the-package-level-logger-anti-pattern
> - 